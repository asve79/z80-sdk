	module wind

MAXWIND	EQU	5
MAXPARS	EQU	2

	macro   VCALL	irg, offs
	LD	L,(irg+offs)
	LD	H,(irg+offs+1)
	CALL	JP_HL
	ENDM

WIN_STO:
	EX	(SP),HL
	LD	(WINS1+1),HL
	POP	HL
	PUSH	IY
	PUSH	IX
WIN_IY:	LD	IY,0
WINS1:	CALL	0
	POP	IX
	POP	IY
	RET

MUL_LE:
	XOR	A
	LD	D,A
	LD	H,A
	EX	DE,HL
	LD	A,L
	LD	L,0
	LD	B,8
MUL1:	RRA
	JR	NC,NDAD
	ADD	HL,DE
NDAD:	EX	DE,HL
	ADD	HL,HL
	EX	DE,HL
	DJNZ	MUL1
	RET

;═════ OPEN A WINDOW ═════
PRINTW 	CALL	WIN_STO
	CALL	CUR_OFF

	LD	(WIN_IY+2),HL
	PUSH	HL
	CALL	WIN_PUSH
	LD	HL,0	;no mem used
	LD	(MEMWIND),HL
	POP	IY
	BIT	1,(IY+5)
	CALL	Z,WIN_ALLOC

;Draw Window
	LD	L,(IY)	;coord X
	LD	H,(IY+1);coord Y
	CALL	C2
;Top line draw
	LD	A,(IY+2);size X
	LD	B,A
	CP	3
	LD	A,0
	JP	C,WIN_ERROR
	CALL	LNFF
;Middle lines
	LD	A,(IY+3);sizeY
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	C,A
	CP	24
	LD	A,0
	JP	C,WIN_ERROR
	DEC	C
	DEC	C
	DEC	B
	DEC	B
DRW_11:	PUSH	BC
	PUSH	HL
	LD	(HL),10000000B
	INC	HL
DRW_1:	LD	(HL),0
	INC	HL
	DJNZ	DRW_1
	LD	(HL),00000001B
	POP	HL
	POP	BC
	CALL	LENIN
	DEC	C
	JR	NZ,DRW_11
;Bottom line
	INC	B
	INC	B
	CALL	LNFF

;Draw ATTRs
	LD	L,(IY)	;coord X
	LD	H,(IY+1);coord Y
	LD	A,(IY+4);attr
	LD	B,(IY+2);size X
	LD	C,(IY+3);size Y
	PUSH	BC
	PUSH	HL
	CALL	ATTR_SET
	POP	HL
	POP	BC
	DEC	C
	INC	H

DRW_2:	PUSH	HL
	PUSH	BC
	CALL	ATTR_SET	
	BIT	2,(IY+5);shade
	JR	Z,DRW21
	LD	(HL),00000001B
DRW21:	POP	BC
	POP	HL
	INC	H
	DEC	C
	JR	NZ,DRW_2

	BIT	2,(IY+5);shade
	JR	Z,DRW_HD
	INC	L
	LD	A,00000001B
	CALL	ATTR_SET
;window header
DRW_HD:	XOR	A
	LD	(IY+6),A ;initial
	LD	(IY+7),A ;coords
	LD	A,(IY+4) ;attr
	LD	(IY+8),A
	LD	A,(IY+9)
	OR	A
	RET	Z	;no header
;fill top window line
	LD	C,0	;xor
	LD	D,C	;and
	LD	E,0FFH	;or
	LD	L,(IY)
	LD	H,(IY+1)
	LD	B,(IY+2)
	CALL	XOANOR_LINE
	LD	C,(IY+5);for save bit0
	RES	0,(IY+5)
	SET	7,(IY+8);"inverse"
	LD	(IY+7),0;line 0
	PUSH	IY
	POP	HL
	LD	DE,9
	ADD	HL,DE
	CALL	PRINTS_S
	LD	(IY+5),C
	RES	7,(IY+8)
	XOR	A
	LD	(IY+6),A;current
	LD	(IY+7),A;print postn
	RET

;════ CLOSE CURRENT WINDOW ════
ENDW:	CALL	WIN_STO
	CALL	CUR_OFF
	BIT	1,(IY+5) ;was it saved?
	CALL	Z,WIN_DISPOSE ;yes, get
	CALL	WIN_POP
	RET

IAWIND:	LD	A,(WIN_USE)
	LD	(AB_USE),A
	RET

ABWIND:	LD	HL,WIN_USE
	LD	A,(AB_USE)
	CP	(HL)
	RET	Z
	CALL	ENDW
	JR	ABWIND

AB_USE:	DB 0FFH

;─────── MAKE A SOLID LINE "B" ─────
LNFF:	PUSH	BC
	PUSH	HL
LNFF0:	LD	(HL),0FFH
	INC	HL
	DJNZ	LNFF0
	POP	HL
	POP	BC

;──────── SCREEN LINE INCREMENT ────
LENIN:	INC	H
	LD	A,H
	AND	7
	RET	NZ
	LD	A,H
	SUB	8
	LD	H,A
	LD	A,L
	ADD	A,32
	LD	L,A
	RET	NC
	LD	A,H
	ADD	A,8
	LD	H,A
	RET

;──────── ATTR LINE INCREMENT ──────
LENINA:	LD	A,L
	ADD	A,32
	LD	L,A
	RET	NC
	INC	H
	RET

;─────────── WINDOW ERRORS ─────────
WIN_ERROR:
	LD	HL,WIN_MSG
	JP	SYSERR
WIN_MSG:
	DB 13,10,'WINDOWS ERROR',13,10,'$'
	DB 'Invalid window size$'
	DB 'Stack overflow$'
	DB 'Invalid memory adr$'
;───────────────────────────────────


;─────── PUSH OLD WINDOW DATA ──────
WIN_PUSH:
	LD	HL,WIN_USE
	INC	(HL)
	RET	Z
;return if no windows opened yet
	LD	HL,STACKW
	LD	A,(HL)
	LD	E,A
	CP	MAXWIND*4+1
	LD	A,1	;stk ovfl
	JP	Z,WIN_ERROR
	INC	(HL)
	INC	(HL)
	INC	(HL)
	INC	(HL)
	LD	D,0
	ADD	HL,DE
	PUSH	IY
	POP	DE
;push old wind adr (IY)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
;push data mem adr
	LD	DE,(MEMWIND)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	RET

;───── POP OLD WINDOW DATA ─────
WIN_POP:
	LD	HL,WIN_USE
	DEC	(HL)
	RET	M
;Don't restore unexisting data
	LD	HL,STACKW
;dec stk ptr
	DEC	(HL)
	DEC	(HL)
	DEC	(HL)
	DEC	(HL)
	LD	E,(HL)
	LD	D,0
	ADD	HL,DE
;pop old wind adr (IY)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	(WIN_IY+2),DE
	PUSH	DE
	POP	IY
;pop data mem adr
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	(MEMWIND),DE
	RET

MEMWIND:	DW	0
WIN_USE:	DB	0FFH
WIN_HEAD:	DW	0
STACKW:		DB	1
	DEFS	MAXWIND*4

;────── STORE SCREEN INFO ────────
WIN_ALLOC:
	LD	L,(IY+2) ;size X
	LD	E,(IY+3) ;size Y
	CALL	MUL_LE	;X*Y
	LD	D,H
	LD	E,L
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL	;*8
	ADD	HL,DE	;*9
	BIT	2,(IY+5) ;shade
	JR	Z,WINAL_0
	LD	A,(IY+2)
	ADD	A,(IY+3)
	DEC	A
	LD	E,A
	LD	D,0
	ADD	HL,DE	;(X+Y)*shade
WINAL_0:
	LD	B,H
	LD	C,L
	CALL	dmm.MALLOC
	LD	(MEMWIND),HL
	XOR	A	;"PUT"
	JP	WIN_SWP	;store data

;──── RESTORE SCREEN INFO ────
WIN_DISPOSE:
	LD	HL,(MEMWIND);here was it
	LD	A,H
	OR	L	;zero?
	LD	A,2	;smth wrong...
	JP	Z,WIN_ERROR
	LD	A,1	;"GET"
	PUSH	HL
	CALL	WIN_SWP	;restore scrn
	POP	HL
	JP	dmm.DISPOS	;unhold memory

;PUT/GET Screen bitmaps
;<A=0/1 (PUT/GET)
;<HL=memory addr
WIN_SWP:
	LD	(WSC_1+1),A
	EX	DE,HL	;de=mem adr

	LD	L,(IY)
	LD	H,(IY+1);get win X&Y
	PUSH	HL

	CALL	C2
	LD	A,(IY+3);sizeY
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	C,A

WSWP_1:	LD	B,(IY+2);sizeX
	CALL	WSWP_CYL;put/get line
	CALL	LENIN
	DEC	C
	JR	NZ,WSWP_1
;ok, now operate attrs
	POP	HL	;X&Y
	CALL	AC2
	LD	C,(IY+3);sizeY
	LD	B,(IY+2);sizeX
	JR	WSWP31
WSWP_3:	LD	B,(IY+2)
	BIT	2,(IY+5)
	JP	Z,WSWP31
	INC	B
WSWP31:	CALL	WSWP_CYL
	CALL	LENINA
	DEC	C
	JR	NZ,WSWP_3	
	BIT	2,(IY+5)
	RET	Z
	INC	L
	LD	B,(IY+2)
	CALL	WSWP_CYL
	RET

WSWP_CYL:
	PUSH	HL
WSC_1:	LD	A,0
	OR	A
	JP	Z,WSWP_M
	LD	A,(DE)
	LD	(HL),A
	JP	WSC_0
WSWP_M:	LD	A,(HL)
	LD	(DE),A
WSC_0:	INC	L
	INC	DE
	DJNZ	WSC_1
	POP	HL
	RET

;XOR/AND/OR SCREEN LINE
;<C=xor with
;<D=and with
;<E=or  with
;<HL=coords (for C2)
;<B=line length
XOANOR_LINE:
	CALL	C2
	LD	A,8
XOAN1:	PUSH	AF
	PUSH	BC
	PUSH	HL
XOAN0:	LD	A,(HL)
	XOR	C
	AND	D
	OR	E
	LD	(HL),A
	INC	HL
	DJNZ	XOAN0
	POP	HL
	POP	BC
	POP	AF
	INC	H
	DEC	A
	JR	NZ,XOAN1
	RET

CLSW:	CALL	NO_CUR
	DI
	LD	A,(IY+5)
	AND	1
	LD	C,A	;Граница окна
	ADD	A,(IY)
	LD	L,A	;Абс коорд X
	LD	A,(IY+1)
	ADD	A,C
	LD	H,A	;Абс коорд Y
	LD	A,(IY+2)
	SUB	C
	SUB	C
	LD	B,A	;Размер по X
	LD	A,(IY+3)
	SUB	C
	SUB	C
	LD	C,A	;Размер по Y

CLSW0:	PUSH	BC
	PUSH	HL
	LD	C,0
	LD	D,C
	LD	E,C
	CALL	XOANOR_LINE ;Clear line
	POP	HL
	PUSH	HL
	LD	A,(IY+4) ;Атрибут
	CALL	ATTR_SET
	POP	HL
	POP	BC
	INC	H
	DEC	C
	JR	NZ,CLSW0
	LD	(IY+6),C ;Курсор в
	LD	(IY+7),C ;начало коорд
	EI
	RET

SOUND0:	LD	DE,0A05H
	JR	LDA6C
SOUND1:	LD	DE,6008H
	JR	LDA6C
SOUND2:	LD	DE,407FH

LDA6C:	LD	A,(SOUNDF)
	RRA
	RET	NC
	LD	A,(BORDER)
LDA74:	OUT	(0FEH),A
	XOR	10H
	EX	AF,AF'
	CALL	RND
	AND	7FH
	ADD	A,E
	LD	B,A
LDA80:	DJNZ	LDA80
	EX	AF,AF'
	DEC	D
	JR	NZ,LDA74
	RET
RND:	PUSH	HL
	LD	HL,(RNDADR)
	INC	HL
	RES	5,H
	LD	(RNDADR),HL
	LD	A,R
	XOR	(HL)
	POP	HL
	RET
RNDADR:	DEFW	0
SOUNDF:	DEFB	081H
BORDER:	DEFB	0

ATR_CALE:
	CALL	WIN_STO
	LD	A,(IY+5)
	AND	1
	LD	C,A
	ADD	A,L
	ADD	A,(IY)
	LD	L,A
	LD	A,H
	ADD	A,C
	ADD	A,(IY+1)
	LD	H,A
	RET

ATRSET:	CALL	ATR_CALE
ATTR_SET:
	PUSH	AF
	CALL	AC2
	POP	AF
ATS0:	LD	(HL),A
	INC	HL
	DJNZ	ATS0
	RET

ATR_CMNU:
	LD	L,(IX)
	LD	H,(IX+1)
	LD	B,(IX+2)
ATR_CALC:
	LD	A,(IY)
	ADD	A,L
	LD	L,A
	LD	A,(IY+1)
	ADD	A,H
	LD	H,A
	BIT	0,(IY+5)
	RET	Z
	INC	H
	INC	L
	RET

ATRINV:	CALL	ATR_CALE
INVATR:	CALL	AC2
INVAT0:	LD	A,(HL)
	AND	00000111B
	RLCA
	RLCA
	RLCA
	LD	C,A
	LD	A,(HL)
	AND	00111000B
	RRCA
	RRCA
	RRCA
	OR	C
	LD	C,A
	LD	A,(HL)
	AND	11000000B
	OR	C
	LD	(HL),A
	INC	HL
	DJNZ	INVAT0
	RET

GOTOHL8_S:
	LD	(IY+7),H
	LD	A,L
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	(IY+6),A
	RET

LB_DRAW:
	CALL	WIN_STO
LB_DRAW_S:
	LD	L,(IX)	  ;Frame X
	LD	H,(IX+1)  ;Frame Y
	LD	C,(IX+6)  ;Frame It
	LD	B,(IX+3)  ;Fsize Y
DLB1:	PUSH	HL
	PUSH	BC
	CALL	GOTOHL8_S
	CALL	ATR_CALC
	LD	B,(IX+2)  ;FSize X
	PUSH	HL
	PUSH	BC
	LD	A,(IX+10) ;Attr
	CALL	ATTR_SET
	POP	BC
	POP	HL
	LD	A,(IX+4)
	DEC	A
	CP	C
	JR	NC,DLB2
	LD	C,0
	LD	D,C
	LD	E,C
	CALL	XOANOR_LINE
	JR	DLB3
DLB2:	VCALL	IX,8	;GetStr
DLB3:	POP	BC
	POP	HL
	INC	H
	INC	C
	DJNZ	DLB1
	RET
LB_DRWIT:
	LD	L,(IX) ;Frame X
	LD	A,(IX+1) ;Frame Y
	ADD	A,(IX+7) ;Item Rel
	LD	H,A
	CALL	GOTOHL8_S
	LD	C,(IX+5) ;Cur It
	VCALL	IX,8
	RET

ILISTB:	CALL	WIN_STO
	XOR	A
	LD	(IX+5),A  ;Cur It
	LD	(IX+6),A  ;FrameIt
	LD	(IX+7),A  ;It Rel
	CALL	LB_DRAW_S
	RET

RLISTB:	CALL	WIN_STO
RLB0:	LD	L,(IX)	  ;FrameX
	LD	A,(IX+1)  ;FrameY
	ADD	A,(IX+7)  ;FrameIt
	LD	H,A
	LD	B,(IX+2)  ;FSize X
	CALL	ATR_CALC
	PUSH	HL
	PUSH	BC
	CALL	INVATR
	CALL	spkeyb.CONIN
	POP	BC
	POP	HL
	PUSH	AF
	CALL	INVATR
	POP	AF
	CP	25
	JR	Z,RLB_UP
	CP	26
	JR	Z,RLB_DN
	CP	11H
	JR	Z,RLB_PGUP
	CP	1
	JP	Z,RLB_PGDN
	RET

RLB_UP:	LD	A,(IX+7) ;Item Rel
	OR	A
	JR	Z,RLBU1
	DEC	(IX+7)	;Item Rel
	DEC	(IX+5)	;Item Cur
	JR	RLB0
RLBU1:	LD	A,(IX+6)
	OR	A
	JR	Z,RLB0
	DEC	(IX+5)
	DEC	(IX+6)
	LD	L,(IX)
	LD	H,(IX+1)
	LD	E,(IX+2)
	LD	D,(IX+3)
	CALL	SCRL_DN_S
	CALL	LB_DRWIT
	JR	RLB0

RLB_DN:	LD	A,(IX+5) ;Item Cur
	INC	A
	CP	(IX+4)	;Maximum
	JR	NC,RLB0
	LD	A,(IX+7) ;Item Rel
	INC	A
	CP	(IX+3)	;FSize Y
	JR	NC,RLBD1
	LD	(IX+7),A
	INC	(IX+5)	;Item Cur
	JR	RLB0
RLBD1:	INC	(IX+6)	;Frame It
	INC	(IX+5)
	LD	L,(IX)
	LD	H,(IX+1)
	LD	E,(IX+2)
	LD	D,(IX+3)
	CALL	SCRL_UP_S
	CALL	LB_DRWIT
RLB00:	JP	RLB0

RLB_PGUP:
	LD	A,(IX+6) ;FrameIt
	OR	A
	JR	Z,RLB00
	LD	C,(IX+3) ;FSizeY
	SUB	C
	JR	NC,RLBPU0
	XOR	A
	LD	(IX+7),A ;Item Rel
RLBPU0:	LD	(IX+6),A
	CALL	LB_ITCAL
	LD	(IX+5),A
	CALL	LB_DRAW_S
	JR	RLB00

RLB_PGDN:
	LD	C,(IX+3) ;FSizeY
	LD	B,(IX+4) ;Maximum
	LD	A,(IX+6) ;FrameIt
	ADD	A,C
	CP	B
	JR	NC,RLB00
	ADD	A,C
	CP	B
	JR	C,RLBPD0
	JR	Z,RLBPD0
	LD	A,C
	DEC	A
	LD	(IX+7),A ;Item Rel
	LD	A,B
RLBPD0:	SUB	C
	JR	RLBPU0

LB_ITCAL:
	LD	A,(IX+6)
	ADD	A,(IX+7)
	RET

IMENU:	CALL	WIN_STO
	LD	HL,(MENUADR)
	LD	A,H
	OR	L
	JR	Z,IMENU0
	DEC	HL
	LD	A,(MNU_ITEM)
	LD	(HL),A
	LD	A,(IX)
IMENU0:	LD	(MNU_ITEM),A
	INC	IX
	LD	(MENUADR),IX
IMENU1:	LD	A,(IX)
	OR	A
	RET	M
	CALL	ATR_CMNU
	LD	A,(IX+3)
	CALL	ATTR_SET
	LD	A,(IX)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	(IY+6),A
	LD	A,(IX+1)
	LD	(IY+7),A
	LD	L,(IX+4)
	LD	H,(IX+5)
	CALL	PRINTS_S
	LD	DE,16
	ADD	IX,DE
	JR	IMENU1

RMENU:	CALL	WIN_STO
RMENU_S:
	LD	A,(MNU_ITEM)
	LD	IX,(MENUADR)
	OR	A
	JR	Z,RMENU1
	LD	DE,16
RMENU0:	ADD	IX,DE
	DEC	A
	JR	NZ,RMENU0
RMENU1:	CALL	ATR_CMNU
	CALL	INVATR
	CALL	spkeyb.CONIN
	PUSH	AF
	CALL	ATR_CMNU
	CALL	INVATR
	POP	AF
	CP	8
	JR	Z,M_ARRS
	CP	24
	JR	C,RMENU2
	CP	27
	JR	C,M_ARR0
RMENU2:	CP	13
	RET	NZ
	LD	B,4
MIGA:	PUSH	BC
	LD	B,3
HLT:	HALT
	DJNZ	HLT
	CALL	ATR_CMNU
	CALL	INVATR
	POP	BC
	DJNZ	MIGA
	LD	L,(IX+14) ;Execution
	LD	H,(IX+15) ;Addr
	CALL	JP_HL
	CP	A	;Признак ENTER
	RET

M_ARRS:	LD	A,23
M_ARR0:	SUB	20	;23-6/2
	ADD	A,A
	LD	E,A
	LD	D,0
	ADD	IX,DE
	LD	A,(IX+1)
	OR	A
	JR	Z,M_ARR1
	LD	H,A
	LD	L,(IX)
	CALL	JP_HL
	JR	RMENU_S
M_ARR1:	LD	A,(IX)
	LD	(MNU_ITEM),A
	JR	RMENU_S

MENUADR:
	DW	0
MNU_ITEM:
	DB	0

SCRW_UP:
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	HL,0
	LD	E,(IY+2)
	LD	D,(IY+3)
	BIT	0,(IY+5)
	JR	Z,SCRLW0
	DEC	E
	DEC	E
	DEC	D
	DEC	D
SCRLW0:	CALL	SCRL_UP_S
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET

SCRL_COR:
	LD	A,(IY)
	ADD	A,L
	LD	L,A
	LD	A,(IY+1)
	ADD	A,H
	LD	H,A
	BIT	0,(IY+5)
	JR	Z,SCRL_COR0
	INC	H
	INC	L
SCRL_COR0:
	LD	A,L
	LD	(LDLY+1),A
	LD	A,E
	LD	(TRNL_Y+1),A
	LD	L,D
	RET

SCRL_DN:
	CALL	WIN_STO
SCRL_DN_S:
	CALL	SCRL_COR
	LD	A,H
	ADD	A,L
	DEC	A
	LD	H,A
SCDN_1:	PUSH	HL
	CALL	LDLY
	EX	DE,HL
	POP	HL
	DEC	H
	DEC	L
	JR	Z,SCR_CLU
	CALL	TRNLIN
	JR	SCDN_1

SCRL_UP:
	CALL	WIN_STO
SCRL_UP_S:
	CALL	SCRL_COR
SCUP_1:	PUSH	HL
	CALL	LDLY
	EX	DE,HL
	POP	HL
	INC	H
	DEC	L
	JR	Z,SCR_CL
	CALL	TRNLIN
	JR	SCUP_1

TRNLIN:	PUSH	HL
	CALL	LDLY
	LD	A,8
	LD	B,0
TRNL_Y:	LD	C,0
TRNL_0:	PUSH	HL
	PUSH	DE
	PUSH	BC
	LDIR
	POP	BC
	POP	DE
	POP	HL
	INC	D
	INC	H
	DEC	A
	JR	NZ,TRNL_0
	POP	HL
	RET

SCR_CLU:
	INC	H
	INC	H

SCR_CL:	DEC	H
	CALL	LDLY
	LD	A,(TRNL_Y+1)
	LD	C,8
SCCL_1:	PUSH	HL
	LD	B,A
SCR_CY:	LD	(HL),0
	INC	L
	DJNZ	SCR_CY
	POP	HL
	INC	H
	DEC	C
	JR	NZ,SCCL_1
	RET

LDLY:	LD	L,0

C2:	LD	A,H
	AND	7
	RRCA
	RRCA
	RRCA
	OR	L
	LD	L,A
	LD	A,H
	AND	248
	OR	64
	LD	H,A
	RET
AC2:	LD	A,H
	RRCA
	RRCA
	RRCA
	LD	H,A
	AND	11100000B
	OR	L
	LD	L,A
	LD	A,H
	AND	00000111B
	OR	58H
	LD	H,A
	RET

PRINTC:	CALL	WIN_STO
PRINTC_S:
	PUSH	IX
	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	AF
	LD	HL,P_RET
	PUSH	HL
	CALL	NO_CUR

	LD	HL,PAR_REMAIN
	LD	C,(HL)
	INC	C
	JR	Z,NO_PAR
;Accept next parameter
	EX	DE,HL
	LD	HL,PAR_DATA
	DEC	C
	LD	B,0
	ADD	HL,BC
	LD	(HL),A
	EX	DE,HL
	DEC	C
	LD	(HL),C
	RET	P
;Execute ctrl code
EXECTR:	LD	HL,(CMD_ADR)
JP_HL:	JP	(HL)

NO_PAR:	CP	32
	JR	NC,P_CHAR
	LD	DE,4
	LD	HL,TBL_CODES
NXT_COD:
	BIT	7,(HL)
	JR	NZ,P_CHAR
	CP	(HL)
	JR	Z,ACC_CO
	ADD	HL,DE
	JR	NXT_COD
ACC_CO:
	INC	HL
	LD	A,(HL)
	INC	HL
	DEC	A
	LD	(PAR_REMAIN),A
	LD	DE,CMD_ADR
	LDI
	LDI
	OR	A
	RET	P
	JR	EXECTR

CHK_CRLF:
	LD	A,(IY+5)
	AND	1
	LD	C,A
	LD	A,(IY+2) ;SIZEX
	SUB	C
	SUB	C
	ADD	A,A
	ADD	A,A
	ADD	A,A
	SUB	6
	CP	(IY+6)	;XPOS
	JP	C,CRLF
	RET
POS_WRK:
	LD	A,(IY+6)
	AND	11111000B
	RRCA
	RRCA
	RRCA
	ADD	A,(IY+0) ;WINDOWX
	ADD	A,C
	LD	L,A
	LD	A,(IY+7) ;YPOS
	ADD	A,(IY+1) ;WINDOWY
	ADD	A,C
	LD	H,A
	JP	C2

P_CHAR:
	SUB	32
	RET	C
	LD	H,0
	LD	L,A

	CALL	CHK_CRLF
	LD	DE,edznak.ZNAK
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,DE
	PUSH	HL
	POP	IX
	LD	DE,0FC00H
	LD	A,(IY+6)
	AND	7
	JP	Z,NRMAS
	LD	B,A
RMASK:	SRL	D
	RR	E
	DJNZ	RMASK
NRMAS:	CALL	POS_WRK
	LD	B,8
N_LINE:	PUSH	BC
	PUSH	DE
	LD	A,(IX)
	BIT	7,(IY+8)
	JP	Z,NOINV
	CPL
NOINV:	AND	11111100B
	LD	D,A
	LD	E,0
	LD	A,(IY+6)
	AND	7
	JP	Z,NRDAT
	LD	B,A
RDATA:	SRL	D
	RR	E
	DJNZ	RDATA
NRDAT:	LD	B,D
	LD	C,E
	POP	DE
	LD	A,D
	CPL
	AND	(HL)
	OR	B
	LD	(HL),A
	LD	A,E
	OR	A
	JP	Z,ONEBY
	CPL
	INC	L
	AND	(HL)
	OR	C
	LD	(HL),A
	DEC	L
ONEBY:	POP	BC
	INC	H
	INC	IX
	DJNZ	N_LINE
	LD	A,(IY+6)
	ADD	A,6
	LD	(IY+6),A
	RET
P_RET:	POP	AF
	POP	BC
	POP	DE
	POP	HL
	POP	IX
	RET

C_RIGHT:
	LD	A,(IY+2)
	BIT	0,(IY+5)
	JR	Z,C_RIG0
	SUB	2
C_RIG0:	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	A,(IY+6)
	ADD	A,6
	LD	(IY+6),A
	CP	C
	RET	C

CRLF:	LD	(IY+6),0
	LD	A,(IY+7)
	INC	A
	LD	B,(IY+3)
	BIT	0,(IY+5)
	JR	Z,CRLF0
	DEC	B
	DEC	B
CRLF0:	CP	B
	JP	NC,SCRW_UP
	LD	(IY+7),A
	RET

C_LEFT:	LD	A,(IY+6)
	SUB	6
	LD	(IY+6),A
	RET	NC
	PUSH	BC
	LD	A,(IY+2)
	BIT	0,(IY+5)
	JR	Z,CLEF0
	SUB	2
CLEF0:	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	C,6
	SUB	C
	LD	B,A
	XOR	A
CLEF1:	ADD	A,C
	CP	B
	JR	C,CLEF1
	SUB	C
	LD	(IY+6),A
	POP	BC

C_UP:	LD	A,(IY+7)
	DEC	A
	RET	M
	LD	(IY+7),A
	RET

C_DOWN:	INC	(IY+7)
	LD	A,(IY+7)
	BIT	0,(IY+5)
	JR	Z,CDOW0
	ADD	A,2
CDOW0:	CP	(IY+3)
	RET	C
	LD	(IY+7),0
	RET

GOTOXY:	LD	HL,PAR_DATA
	LD	A,(HL)
	LD	(IY+7),A
	INC	HL
	LD	A,(HL)
	LD	C,A
	ADD	A,A
	ADD	A,C
	ADD	A,A
GXYZ:	LD	(IY+6),A
	RET

GOTOXY8:
	LD	HL,PAR_DATA
	LD	A,(HL)
	LD	(IY+7),A
	INC	HL
	LD	A,(HL)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	JR	GXYZ

ST_COLOR:
	LD	A,(PAR_DATA)
	LD	(IY+8),A
	RET

HL_HEX:	CALL	WIN_STO
	JR	HL_HEX_S
A_HEX:	CALL	WIN_STO
	JR	A_HEX_S

PR_STRING:
	LD	HL,PAR_DATA
	LD	D,(HL)
	INC	HL
	LD	E,(HL)
	EX	DE,HL
	JP	PRINTS_S

PR_BYTE:
	LD	HL,PAR_DATA
	LD	D,(HL)
	INC	HL
	LD	E,(HL)
	LD	A,(DE)
	JR	A_HEX_S

PR_WORD:
	LD	HL,PAR_DATA
	LD	D,(HL)
	INC	HL
	LD	E,(HL)
	EX	DE,HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL

HL_HEX_S:
	LD	A,H
	CALL	A_HEX_S
	LD	A,L
A_HEX_S:
	PUSH	AF
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	A_HEX0
	POP	AF
A_HEX0:	AND	0FH
	ADD	A,90H
	DAA
	ADC	A,40H
	DAA
	JP	PRINTC_S

INTCUR	LD	A,(CURM)
	OR	A
	RET	Z
	AND	01111111B
	SUB	2
	JR	NC,CWAIT
	AND	1
	ADD	A,21
	PUSH	AF
	CALL	PRCUR
	POP	AF
CWAIT:	OR	128
	PUSH	AF
	JR	COF1

CUR_ON:	PUSH	AF
	LD	A,10000100B
	JR	COF1

CUR_OFF:
	PUSH	AF
	CALL	NO_CUR
	XOR	A
COF1:	LD	(CURM),A
	POP	AF
	RET

NO_CUR:	PUSH	AF
	LD	A,(CURM)
	AND	10000111B
	LD	(CURM),A
	RRCA
	CALL	C,PRCUR
	POP	AF
	RET

PRCUR:	CALL	WIN_STO
	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	AF
	CALL	CHK_CRLF
	LD	A,(IY+6)
	LD	DE,0F800H
	AND	7
	JR	Z,NRCUR
	LD	B,A
RCUR:	SRL	D
	RR	E
	DJNZ	RCUR
NRCUR:	CALL	POS_WRK
	LD	A,H
	ADD	A,7
	LD	H,A
	LD	A,D
	XOR	(HL)
	LD	(HL),A
	INC	L
	LD	A,E
	XOR	(HL)
	LD	(HL),A
	LD	A,(CURM)
	XOR	1
	LD	(CURM),A
	POP	AF
	POP	BC
	POP	DE
	POP	HL
	RET

GOTODE:	CALL	WIN_STO
GOTODE_S:
	LD	A,22
	CALL	PRINTC_S
	LD	A,E
	CALL	PRINTC_S
	LD	A,D
	JP	PRINTC_S

EDWORD:	CALL	WIN_STO
	CALL	GOTODE_S
	PUSH	DE
	PUSH	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,EDWBUF+1
	EX	DE,HL
	CALL	BOERP
	LD	HL,EDWBUF
	CALL	INP_STR_S
	CP	27
	JR	Z,EDW_AB
	XOR	A
	LD	(EDWBUF+5),A
	LD	DE,EDWBUF+1
	CALL	PREOB
	EX	DE,HL
	POP	HL
	PUSH	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
EDW_AB:	POP	HL
	POP	DE
	CALL	GOTODE_S
	LD	A,4
	CALL	PRINTC_S
	LD	A,L
	CALL	PRINTC_S
	LD	A,H
	JP	PRINTC_S

EDWBUF:	DB 4,'0000!'

PREOB:	LD	HL,0
PREOB0:	LD	A,(DE)
	INC	DE
	CP	' '
	JR	Z,PREOB0
	SUB	'0'
	CP	10
	JR	C,PREOB1
	SUB	7
	CP	16
	RET	NC
	CP	10
	RET	C
PREOB1:	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	OR	L
	LD	L,A
	JR	PREOB0

BOERP:	LD	A,H
	CALL	BOERP0
	LD	A,L
BOERP0:	PUSH	AF
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	BOERP1
	POP	AF
BOERP1:	AND	0FH
	ADD	A,90H
	DAA
	ADC	A,40H
	DAA
	LD	(DE),A
	INC	DE
	RET

IST_PRBUF:
	LD	E,(IY+6)
	LD	D,(IY+7)
	LD	B,(HL)
	INC	HL
	CALL	OUTNS_S
	LD	(IY+6),E
	LD	(IY+7),D
	RET

INP_STR:
	CALL	WIN_STO
INP_STR_S:
	PUSH	HL
	CALL	IST_PRBUF
	CALL	CUR_ON
	LD	HL,CUR_OFF
	EX	(SP),HL
	LD	D,(HL)
	LD	E,0
	INC	HL
	PUSH	DE
	PUSH	HL
	CALL	spkeyb.CONIN
	POP	HL
	POP	DE
	CP	32
	JR	C,INPSX0
	PUSH	DE
	PUSH	HL
	LD	B,D
IS_CLB:	LD	(HL),32
	INC	HL
	DJNZ	IS_CLB
	POP	HL
	PUSH	HL
	DEC	HL
	PUSH	AF
	CALL	IST_PRBUF
	POP	AF
	POP	HL
	POP	DE
	JR	INPSX0
INPST0:	PUSH	HL
	PUSH	DE
	CALL	spkeyb.CONIN
	POP	DE
	POP	HL
INPSX0:	CP	8
	JR	Z,I_LEFT
	CP	24
	JR	Z,I_RIGHT
	CP	25
	RET	Z
	CP	26
	RET	Z
	CP	13
	RET	Z
	CP	127
	JR	Z,I_DEL
	CP	27
	RET	Z
	CP	9
	RET	Z
	CP	32
	JR	C,INPST0
;Accept character
	LD	C,A
	LD	A,E
	CP	D
	JR	Z,INPST0
	LD	(HL),C
	LD	A,C
	CALL	PRINTC_S
	INC	HL
	INC	E
	JR	INPST0

I_LEFT:	LD	A,E
	OR	A
	JR	Z,INPST0
	DEC	E
	DEC	HL
INPST1:	LD	A,8
	CALL	PRINTC_S
	JR	INPST0

I_RIGHT:
	LD	A,E
	CP	D
	JR	Z,INPST0
	LD	A,24
	CALL	PRINTC_S
	INC	E
	INC	HL
	JR	INPST0
I_DEL:	LD	A,E
	OR	A
	JR	Z,INPST0
	LD	A,8
	CALL	PRINTC_S
	DEC	HL
	DEC	E
	LD	A,32
	LD	(HL),A
	CALL	PRINTC_S
	JR	INPST1

OUTNS:	CALL	WIN_STO
OUTNS_S:
	LD	A,(HL)
	CALL	PRINTC_S
	INC	HL
	DJNZ	OUTNS_S
	RET

SOBN:	OR	A
	JR	Z,PRINTS
	DEC	A
	EX	AF,AF'
SOBN0:	LD	A,(HL)
	INC	HL
	OR	A
	JR	NZ,SOBN0
	EX	AF,AF'
	JR	SOBN

PRINTS:	CALL	WIN_STO
PRINTS_S:
	LD	A,(PAR_REMAIN)
	OR	A
	LD	A,(HL)
	INC	HL
	JP	P,PRS_NC
	CP	1
	RET	C
	JR	Z,CENTRE
PRS_NC:	CALL	PRINTC_S
	JR	PRINTS_S
CENTRE:	CALL	NO_CUR
	PUSH	HL
	PUSH	BC
	LD	C,0
CENT0:	LD	A,(HL)
	CP	20H
	JR	C,CENT1
	INC	HL
	INC	C
	JR	CENT0
CENT1:	LD	A,C
	ADD	A,A
	ADD	A,C
	ADD	A,A
	LD	C,A
	LD	A,(IY+5)
	AND	1
	LD	B,A
	LD	A,(IY+2)
	SUB	B
	SUB	B
	ADD	A,A
	ADD	A,A
	ADD	A,A
	SUB	C
	SRL	A
	LD	(IY+6),A
	POP	BC
	POP	HL
	JR	PRINTS_S

TBL_CODES:
	DB	13,0
	DW	CRLF
	DB	8,0
	DW	C_LEFT
	DB	24,0
	DW	C_RIGHT
	DB	25,0
	DW	C_UP
	DB	26,0
	DW	C_DOWN
	DB	22,2
	DW	GOTOXY
	DB	21,2
	DW	GOTOXY8
	DB	23,1
	DW	ST_COLOR
	DB	2,0
	DW	CUR_ON
	DB	3,0
	DW	CUR_OFF
	DB	4,2
	DW	PR_WORD
	DB	5,2
	DW	PR_STRING
	DB	6,2
	DW	PR_BYTE
	DB	31,0
	DW	CLSW
	DB 0FFH

CURM:	DB	0	;Cursor status
PAR_REMAIN:
	DB	0FFH
PAR_DATA:
	DS	MAXPARS
CMD_ADR:
	DW	0
	endmodule

;	include "edznak.a80"
