		module zifi

pCMOS_ADDR	EQU	#DFF7
pCMOS_DATA	EQU	#BFF7
pCMOS_CONF	EQU	#EFF7

;------------------------------------------------------------------------------------
;Вспомогательные модуля
;------------------------------------------------------------------------------------
;Ожидание статуста выполнения команды и вывод кода. TODO: Обработка таймаута
;i:
; HL - bufer
;o: A=0 - OK
;   A=1 - ERROR
;   A=2 - TIMEOUT
wait_status	DI
		PUSH	BC
		PUSH	DE
		PUSH	HL
		LD	(ptr),HL
		DEC	HL
		call	getRTCsec
		DEC	A
		CP	#FF
		JR	NZ,ws19
		LD	A,59
ws19		LD	(bsecond),A			;откуда начался отсчет. нужно для контролья перехода 59->0
		;PUSH	AF
		;_a_hex
		;POP	AF
		LD	b,a
		LD	A,(timeout)
		ADD	B	 			;добавим к значению сколько секунд ждем
		LD	(sectimeout),A			;Вычислили значение после которого считаем что наступил таймаут
		;_a_hex
		LD	BC,0000				;????????
		JR	ws2
ws20		NOP					;Основной цикл
		call	getRTCsec			;берем текущее значение секунд
		;_a_hex
		PUSH	BC
		LD	B,A
		LD	A,(bsecond)
		CP	B
		JR	C,ws21				;если A(bsecond) < B(current seconds) то перескока 59-0 небыло
		LD	A,B
		add	60
		LD	B,A
ws21		LD	A,(sectimeout)			;а теперь проверяем на таймаут
		CP	B
		JR	C,ws_timeout			;если A(timeout marker) < B(current seconds + corrector) то значит наступил таймаут
		POP	BC
ws2		CALL	uart_ts_zifi.rx_fifo_cnt
		OR	A
		JR	Z,ws20				;wait data
		CALL	uart_ts_zifi.read_fifo_byte	;read byte
		LD	(HL),A
		INC	HL
		INC	BC
		CP	10				;if end-of-line (code 13)
		JR	NZ,ws2				;
		PUSH	HL
		PUSH	BC
wc4		LD	DE,msg_ok			;ПРоверка статуста ОК
		LD	BC,5
		CALL	check_status
		OR	A
		JR	NZ,ws7				;Если ОК
		LD	DE,msg_error
		LD	BC,8
		CALL	check_status
		OR	A
		JR	NZ,ws6				;Если ERROR
		POP	BC
		POP	HL				;Запоминаем позици идем дальше
		DEC	HL
		LD	(ptr),HL
		INC	HL
		JR	ws2
ws7		POP	BC
		POP	HL
		XOR	A				;ОК
		JR	ws8
ws6		POP	BC
		POP	HL
		LD	A,1				;ERROR
ws8		POP	HL
		POP	DE
		POP	BC
		EI
		RET
ws_timeout	POP	BC
		LD	A,2				;TIMEOUT
		JR	ws8

sectimeout	DB	0				;Значение секунд которое будет считаться наступлением таймаута
bsecond		DB	0				;начальные секунды
timeout		DB	10				;таймаут операции в секундах
;i:
; (ptr) - казатель на буфер
; DL - эталон, с которым сравниваем
; BC - длина строки
;o:
; A:
; 0 - не совпал
; 1 - совал
check_status	PUSH	HL
		LD	HL,(ptr)
;		PUSH	HL
;		PUSH	DE
;		PUSH	BC
;		LD	A,'E'
;		_printc
;		POP	BC
;		POP	DE
;		POP	HL
cstat_loop	;PUSH	HL
;		PUSH	DE
;		PUSH	BC
;		LD	A,">"
;		_printc
;		LD	A,(HL)
;		_a_hex
;		LD	A,(DE)
;		_a_hex
;		LD	A,"<"
;		_printc
;		POP	BC
;		POP	DE
;		POP	HL
		LD	A,(DE)
		CPI
		JNZ	cstat_nf
		INC	DE
		INC	C
		DEC	C
		JR	NZ,cstat_loop
		LD	A,1
;		PUSH	AF
;		_a_hex
;		LD	A,"*"
;		_printc
;		POP	AF
;		PUSH	HL
;		PUSH	DE
;		PUSH	BC
;		LD	A,'L'
;		_printc
;		POP	BC
;		POP	DE
;		POP	HL

		POP	HL
		RET
cstat_nf	XOR	A
;		PUSH	AF
;		_a_hex
;		LD	A,"*"
;		_printc
;		POP	AF
;		PUSH	HL
;		PUSH	DE
;		PUSH	BC
;		LD	A,'l'
;		_printc
;		POP	BC
;		POP	DE
;		POP	HL


		POP	HL
		RET

msg_ok		DB	10,'OK',13,10
msg_error	DB	10,'ERROR',13,10
ptr		DW	0		;указатель
connections	DB	0		;счетчик соединений
registry	DS	5*9,0		;реестр соединений <id><адрес буфера><максимальный размер буфера>

;http://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispHL
;Number in de to decimal ASCII on HL
;Thanks to z80 Bits
;inputs:
; de = number
; hl = bufer to write
;example: de=300 outputs '00300'
;destroys: af, bc, hl, de used
de_dec_hl_save	PUSH	AF
		PUSH	BC
		PUSH	DE
		PUSH	HL
		CALL	de_dec_hl
		POP	HL
		POP	DE
		POP	BC
		POP	AF
		RET
de_dec_hl	EX	DE,HL
		LD	(de_pos),HL
		ld	bc,-10000
		call	Num1
		ld	bc,-1000
		call	Num1
		ld	bc,-100
		call	Num1
		ld	c,-10
		call	Num1
		ld	c,-1
Num1		ld	a,'0'-1
Num2		inc	a
		add	hl,bc
		jr	c,Num2
		sbc	hl,bc
		call 	PUTCHAR
		RET
de_pos		DW	0
PUTCHAR		PUSH	HL
		LD	HL,(de_pos)
		LD	(HL),A
		INC	HL
		LD	(HL),A
		POP	HL
		RET

;- Взять значение секунд (для отслеживания таймаутов)
;o: a - seconds
getRTCsec 	PUSH	bc
		ld	a,#80
		ld	bc,pCMOS_CONF
		out	(c),a

		ld	a,#0B
		ld	b,high pCMOS_ADDR
		out	(c),a
		ld	a,#82
		ld	b,high pCMOS_DATA
		out	(c),a
;- seconds -
		ld	a,#00
		ld	b,high pCMOS_ADDR
		out	(c),a
		ld	b,high pCMOS_DATA
		in	a,(c)
		POP	bc
		ret


;-------------------------------------------------------------------------------
;отправить команду из буфера
;i: HL - command
send_cmd	LD	A,(HL)
		OR	A
		RET	Z
		CALL	uart_ts_zifi.send_fifo_byte
		PUSH 	HL
		LD	A,(HL)
		_printc
		POP	HL
		INC	HL
		JR	send_cmd

;-------------------------------------------------------------------------------
;o:
; A=0 - OK
; A=1 - ERROR
init		PUSH	HL
		LD	A,10
		LD	(timeout),A
		CALL	uart_ts_zifi.init
		OR	A
		POP	HL
		RET	NZ			;retrun if error
		CALL	uart_ts_zifi.clear_output_fifo
		CALL	uart_ts_zifi.clear_input_fifo
		PUSH	HL
		LD	HL,cmd_check		;Отправка команды "AT"
		CALL	send_cmd
		POP	HL
		CALL	wait_status
		OR	A
		RET	NZ			;retrun if error
		PUSH	HL
		LD	HL,cmd_cipmux		;Включение множественного соединения
		CALL	send_cmd
		POP	HL
;		CALL	wait_status
;		PUSH	HL
;		LD	HL,cmd_cipmode
;		CALL	send_cmd
;		POP	HL
		JP	wait_status

;------------------------------------------------------------------------------------
;i : HL - бевер для операций
;o : HL - результат выполнения операции
;  :  A - 0 - OK, 1- ERROR
list_ap		PUSH	HL
		LD	HL,cmd_cwlap
		CALL	send_cmd
		POP	HL
		JP	wait_status

;-- показать текущий IP -------------------------------------------------------------
;i : HL - бевер для операций
;o : HL - результат выполнения операции
;  :  A - 0 - OK, 1- ERROR
current_ip	PUSH	HL
		LD	HL,cmd_cifsr
		CALL	send_cmd
		POP	HL
		JP	wait_status

;-- Вывести список AP ---------------------------------------------------------------
;i : HL - буфер для операций
;  : DE - ssid,0,pass,0
;o : HL - результат выполнения операции
;  :  A - 0 - OK, 1- ERROR
connect_ap	PUSH 	HL
		EX 	DE,HL
		PUSH	HL
		LD	HL,cmd_cwjap		;отправка команды AT+CWJAP="
		LD	BC,10
		LDIR
		POP	HL			;HL=<ssid>,0,<pass>,0
cap1		LDI				;копируем SSID
		LD	A,(HL)
		OR	A
		JR	NZ,cap1
		INC	HL
		PUSH	HL
		LD	HL,cmd_quetesp		;копируем разделитель ","
		LD	BC,3
		LDIR
		POP	HL			;HL=<pass>,0
cap2		LDI				;копируем пароль
		LD	A,(HL)
		OR	A
		JR	NZ,cap2
		LD	HL,cmd_quetesend	;копируем завершение строки ",13,10,0
		LD	BC,4
		LDIR
		POP	HL
		CALL	send_cmd
		JP	wait_status


;--- Отключить от точки доступа ---------------------------------------------------
;i : HL - буфер для операций
;o : HL - результат
;  :  A - 0 - OK, 1- ERROR
disconnect_ap	PUSH	HL
		LD	HL,cmd_cwqap
		CALL	send_cmd
		POP	HL
		JP	wait_status


;-- Открыть TCP соединение ----------------------------------------------------------
;i : HL - буфер для операций
;  : DE - address,0,port,0
;  : DE` - адрес буфера, куда будут приходить данные по соединению.
;  : BC - размер буфера
;o : HL - результат
;  :  A - 0-9 - Connection ID, #FF - ERROR
;+CIPSTART: (id), (<⨯>), (<ip>), (<port>)
;AT+CIPSTART=1, "TCP", "192.168.101.100", 1000
open_tcp	PUSH	HL
		LD	A,1		;TODO : проверять соединение в реестре
		LD	HL,registry	;адрес в реестре
		LD	(HL),A
		INC 	HL
		PUSH	HL
		EXX
		POP	HL
		LD	(HL),E
		INC	HL
		LD	(HL),D
		PUSH	HL
		EXX
		POP	HL
		INC	HL
		LD	(HL),C
		INC	HL
		LD	(HL),B
		POP	HL
		PUSH	HL		;-----------------
		PUSH	DE
		EX 	DE,HL		;HL=<host>,0,<port>,0
		PUSH	HL
		LD	HL,cmd_cipstart	;команда AT+CIPSTART="
		LD	BC,12
		LDIR
		LD	A,'1'		;!!!!!!!!!!!!DUMMY!!!!!!!!!!11
		LD	(DE),A
		INC	DE
		LD	HL,cmd_quetesp+1  ;часть команды ',"'
		LD	BC,2
		LDIR
		LD	HL,cmd_tcp	;часть команды TCP","
		LD	BC,6
		LDIR
		POP	HL			;HL=<host>,0,<port>,0
ot1		LDI				;ПИшем SSID
		LD	A,(HL)
		OR	A
		JR	NZ,ot1
		INC	HL
		PUSH	HL
		LD	HL,cmd_quetesp		;промежуточные символы '",'
		LD	BC,2
		LDIR
		POP	HL			;HL=<port>,0
ot2		LDI				;часть команды
		LD	A,(HL)
		OR	A
		JR	NZ,ot2
		LD	HL,cmd_quetesend+1	;закрыть команду 13,10,0
		LD	BC,3
		LDIR
		POP	DE
		POP	HL
		CALL	send_cmd

;		POP	DE
;		POP	HL
		CALL	wait_status
		OR	A
		JR	NZ,ot_err
		;* TODO работа с реестром
		OR	A
		JR	NZ,ot_err
		LD	A,1			;DUMMY
						;тут надо выделять ID соединению
		RET
ot_err		LD	A,#FF			;ERROR
		RET

;-- Закрыть TCP соединение ----------------------------------------------------------
;i : HL - буфер для операций
;  : A - <ID>
;o : HL - результат работы команды
;  :  A - 0 - OK, 1- ERROR
;AT+CIPCLOSE=<id>
close_tcp	PUSH	HL
		EX 	DE,HL
		LD	HL,cmd_close	;команда AT+CIPCLOSE=
		LD	BC,12
		LDIR
		ADD	'0'
		LD	(DE),A		;Тут пишем номер соединения
		INC	DE
		LD	HL,cmd_quetesend+1	;закрывающая часть команды 13,10,0
		LD	BC,3
		LDIR
		POP	HL
		CALL	send_cmd
		JP	wait_status

;-- PING хоста ---------------------------------------------------------------------
;i : HL - буфер для операций
;  : DE - addr,0
;o : HL - результат работы команды
;  :  A - 0 - OK, 1- ERROR
;AT+PING="192.168.1.1"
;AT+PING="www.ya.ru"
ping		PUSH 	HL
		PUSH	DE
		PUSH	HL
		EX 	DE,HL
		PUSH	HL
		LD	HL,cmd_ping		;выполнить команду AT+PING="
		LD	BC,9
		LDIR
		POP	HL			;HL=<ardr>,0
ping1		LDI
		LD	A,(HL)
		OR	A
		JR	NZ,ping1
		INC	HL
		LD	HL,cmd_quetesend		;закрыть команду ",13,10,0
		LD	BC,4
		LDIR
		POP	HL
		CALL	send_cmd
		POP	DE
		POP	HL
		JP	wait_status

;-- Отправить данные ----------------------------------------------------------------
;i : HL - буфер для операций и результата
;  : DE - буфер с данными для отправки
;  : A - <ID> соединения
;  : BC - размер
;o : HL - Ответ
;  :  A - 0 - OK, 1- ERROR
;AT+CIPSEND=<id>, размер; ждем '>' и передаем данные
send		PUSH	HL
		PUSH	DE
		PUSH	BC
		EX 	DE,HL
		PUSH	HL
		LD	HL,cmd_cipsend	;команда AT+CIPSEND=
		PUSH	BC
		LD	BC,11
		LDIR
		POP	BC
		ADD	'0'
		LD	(DE),A		;идентификатор соединения
		INC	DE
		LD	A,','		;разделитель
		LD	(DE),A
		INC	DE
		EX	DE,HL
		PUSH	BC
		POP	DE
		CALL	de_dec_hl_save		;перевести число в строку. Размер блока данных DE -> string -> (HL)
		POP	DE
		POP	HL
		CALL	send_cmd
		POP	BC
		POP	DE
		POP	HL
sendw1		CALL	uart_ts_zifi.rx_fifo_cnt
		OR	A
		JR	Z,sendw1			;wait data
		CALL	uart_ts_zifi.read_fifo_byte	;read byte
		CP	A,">"
		JR	NZ,sendw1			;wait until '>'
		_printc			;/* DEBUG */
		PUSH	HL
		PUSH	DE
		PUSH	BC
send1		LD	A,(DE)		;отправить данные в порт. В <BC> размер блока
		CALL	uart_ts_zifi.send_fifo_byte
		_printc			;/* DEBUG */
		INC	DE
		DEC	BC
		LD	A,C
		OR	A
		JR	NZ,send1
		LD	A,B
		OR	A
		JR	NZ,send1
		POP	BC
		POP	DE
		POP	HL
		JP	wait_status

;-- Принять данные ------------------------------------------------------------------
;i : HL - буфер для операций.
;o : HL - ответ
;  :  A - 0 - OK, 1- ERROR
;AT+IPD
receve		PUSH	HL
		LD	HL,cmd_ipd	;выполнить команду AT+IPD,13,10,0
		LD	BC,11
		LDIR

		POP	HL
		RET



		include	"commands.a80"
		include "../sockets/uart_ts_zifi.a80"
		endmodule
